# 아토믹 코틀린 At 63. 합성

## 용어

#### 재사용 코드

- 객체 지향을 사용해야 하는 가장 큰 이유는 **코드 재사용**이다.
    - **제대로 재사용된 코드는 단 한 곳만 바꿔도 된다.**
    - 객체 지향 프로그래밍에서는 새 클래스를 만듦으로써 코드를 재사용한다.
    - 밑바닥부터 새로 클래스를 만드는 대신 누군가 만들고 디버깅해둔 기존 클래스를 사용한다.
- 핵심은 **기존 코드를 더럽히지 않고 클래스를 재사용하는 것**이다.

- 재사용 코드를 잘 사용하는 방법 중 하나가 **상속**이다.


#### 상속
- 상속을 하면 기존 클래스 타입에 속하는 새 클래스를 만든다.
- 기존 클래스를 변경하지 않고, 기존 클래스의 형식대로 새 클래스에 새 코드를 추가한다.
    - 혹은 기존 클래스의 객체를 새 클래스 안에 생성하는 좀 더 직접적인 접근 방법을 택할 수도 있다.
    - 새 클래스가 기존 클래스들을 합성한 객체로 이뤄지기 때문에 이런 방법을 **합성**이라고 한다.
    - **합성**을 쓸 경우는 기본 코드의 (형태가 아니라) **기능을 재사용하는 것**이다.
- 상속은 `~이다` 관계를 표현한다.

#### 합성
- 합성은 **포함 관계**다.
  - 예를 들어 *집은 건물이며, 부엌을 포함한다.*는 관계를 다음과 같이 표현할 수 있다.

```kotlin
package sec05.composition

interface Building
interface Kitchen

interface House: Building {
    val kitchen : Kitchen
}
```

만약 집에 부엌이 둘 있다면 다음과 같이 할 수 있다.

```kotlin
package sec05.composition2

interface Building 
interface Kitchen

interface House2: Building {
    val kitchen1 : Kitchen
    val kitchen2 : Kitchen
}
```
 
## 예약어 및 코틀린 개념

- 없음.

## 함수

- 없음.

## 참고

#### 상속보단 합성을 택하라
- 합성은 클래스가 커지면 여러 가지 관련이 없는 요소를 책임져야 한다.
- 합성은 각 요소를 서로 분리할 때 도움이 된다.
- 합성은을 사용하면 클래스의 복잡한 로직을 단순화할 수 있다.

#### 합성과 상속 중 선택하기

- 합성은 기존 클래스의 기능을 제공하지만 인터페이스를 제공하지는 않는다.
- 합성한 객체를 완전히 감추고 싶다면 비공개(private)로 포함시키면 된다. 

```kotlin
package sec05.composition

class Features {
    fun f1() = "feature1"
    fun f2() = "feature2"
}

class Form {
    private val features = Features()
    fun operation1() = 
        features.f2() + features.f2()
    fun operation2() =
        features.f1() + features.f1()
}
```

- **합성이 아닌 상속을 선택할 경우 연결 관계가 명확해지는데, 이 관계를 수정하면 해당 연결 관계에 의존하는 모든 코드가 망가진다.**
  - 때문에 클래스 사용자가 우리가 만든 새 클래스의 합성에 직접 접근하는 게 합리적인 경우가 있다.
  - 이런 경우에는 멤버 객체를 공개(public)로 만들 수 있다. 이렇게 공개를 해도 멤버 객체가 적절히 정보 은닉을 구현하고 있는 한 상대적으로 안전하다.


#### 합성 선택
다형성의 영리함으로 인해 모든 것을 상속으로 처리해야 할 것처럼 느끼기 쉽다.
이 느낌은 우리의 설계에 짐이 된다. 
실제로 기존 클래스를 사용해 새 클래스를 만들 때 상속을 우선적으로 선택하면 모든 것이 불필요하게 복잡해진다.
더 나은 접근 방법은 합성을 먼저 시도하는 것이다.
특히 상속과 합성 중 어느 쪽이 더 잘 적용될지 분명히 알 수 없는 경우 합성을 먼저 시도해야 한다.