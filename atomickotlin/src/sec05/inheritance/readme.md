# 아토믹 코틀린 At 58. 상속

## 용어

#### 상속(inheritance)

- 상속(inheritance)은 기존 클래스를 재사용하면서 변경해 새로운 클래스를 만드는 메커니즘이다.

 
## 예약어 및 코틀린 개념

#### 객체

- 객체는 프로퍼티에 데이터를 저장하고 멤버 함수를 통해 동작을 수행한다.
- 각 객체는 메모리에서 고유한 장소를 차지하기 때문에 한 객체의 프로퍼티는 다른 객체의 프로퍼티 값과 다른 값을 가질 수 있다.
- 객체는 어떤 클래스라는 범주에 들어간다.
- 객체는 자신을 만들어낸 `클래스`의 모습을 지닌다.

#### 클래스
- 클래스는 자신에 속한 객체들의 형식(프로퍼티와 함수)을 결정한다.
- 클래스를 만들고 디버깅하려면 확장이 필요하다.


#### 상속(inheritance)
어떤 클래스를 닮았지만 일부 차이가 있는 새 클래스를 만들고 싶다면 어떻게 해야 할까?
새 클래스를 밑바닥부터 완전히 새로 만드는 건 시간 낭비, 노력 낭비다.
객체 지향 언어는 **상속**이라는 재사용 매커니즘을 제공한다.

- 상속은 생물학적 유전(biological inheritance) 개념을 따른다.
  - 기존 클래스로부터 새 클래스를 만들고 싶은데, 몇 가지 추가하고 변경할 내용이 있을 때 사용한다.
- 상속 구문은 인터페이스를 구현하는 구문과 비슷하다.
- 새 클래스 `Derived`가 기존 클래스 `Base`를 상속하려면 `콜론(:)`이 필요하다.

```kotlin
package sec05.inheritance

open class Base

class Derived : Base()
```

~~상속을 할 때 Base 다음에 괄호를 붙여야 하는 이유는 다음 아톰에서 설명한다.~~

- 상속 관계를 표현할 때는 **기반 클래스(base class)**와 **파생 클래스(derived class)**라는 용어를 자주 사용한다.
  - 부모 클래스(parent class)와 자식 클래스(child class), 상위 클래스(superclass)와 하위 클래스(subclass)라고도 한다.
- **기반 클래스는 `open`이어야 한다.**
- `open`으로 지정하지 않은 클래스는 상속을 허용하지 않는다. 
  - **클래스는 기본적으로 상속에 대해 닫혀있다.**

자바에서는 final을 사용해 클래스의 상속을 명시적으로 금지하지 않는 한 클래스는 자동으로 상속이 가능하다.
**코틀린에서도 final을 쓸 수 있지만, 모든 클래스가 기본적으로 final이기 때문에 굳이 final을 지정할 필요가 없다.**

```kotlin
package sec05.inheritance

// 이 클래스는 상속될 수 있다.
open class Parent

class Child : Parent()

// Child는 열려 있지 않으므로 다음 상속은 실패한다.
// class GrandChild : Child()

// 이 클래스는 상속될 수 없다.
final class Single

// 'final'을 쓴 선언과 같은 효과를 낸다.
class AnotherSingle
```

- 코틀린에서는 `open` 키워드를 사용해 해당 클래스가 상속을 고려해 설계됐다는 사실을 명시적으로 드러낸다.

```kotlin
package sec05.inheritance

import atomictest.eq

open class GreateApe {
    val weight = 100.0
    val age = 12
}

open class Bonobo: GreateApe()
class Chimpanzee : GreateApe()
class BonoboB : Bonobo()

fun GreateApe.info() = "wt: $weight age: $age"

fun main() {
    GreateApe().info() eq "wt: 100.0 age: 12"
    Bonobo().info() eq "wt: 100.0 age: 12"
    Chimpanzee().info() eq "wt: 100.0 age: 12"
    BonoboB().info() eq "wt: 100.0 age: 12"
}
```

- `info()`는 `GreateApe`의 확장 함수다.
  - 따라서 당연히 GreateAte 타입의 객체에 대해 이 함수를 호출할 수 있다.
  - 하지만 Bonobo, Chimpanzee, BonoboB 객체에 대해서도 `info()`를 호출할 수 있다.
  - 세 타입은 서로 다른 타입이지만, 코틀린은 이들을 기꺼이 `GreateApe`와 **같은 타입**인 것처럼 받아들인다.
- **하위 클래스를 상위 클래스와 같은 타입으로 취급하는 동작은 상속의 단계가 아무리 깊어도 제대로 작동**한다.

- **상속은 상속한 모든 존재가 항상 부모클래스라고 보장한다.**
- 파생된 클래스의 객체에 작용하는 모든 코드는 이들 중심에 부모 클래스를 품고 있음을 알고 있으므로 **부모클래스의 함수와 프로퍼티를 자손 클래스에서도 여전히 사용할 수 있다.**

- 상속을 사용하면 **그 클래스를 상혹사는 모든 클래스에서 사용할 수 있는 코드를 작성할 수 있다.**
- **상속은 코드를 단순화하고 재사용할 수 있는 기회를 제공한다.**

- 상속은 함수를 `오버라이드(override)`할 때 더 흥미롭ㄴ다.
- 오버라이드는 기반 클래스의 함수를 파생 클래스에서 재정의해 다른 일을 수행하는 것이다.

- 파생 클래스는 기반 클래스의 private 멤버에 접근할 수 없다.
- 기반 클래스를 만든 사람이 특정 멤버에 대한 접근 권한을 파생 클래스에 부여하지만, 일반적으로 그 외의 다른 대상에게는 부여하지 않는다. 
  - `protected` 접근 변경자가 이런 일을 한다.
  - `protected` 멤버는 외부 세계에 대해 닫혀있고, 하위 클래스에서만 접근이나 오버라이드가 가능하다.
    - 멤버를 `protected`로 지정하면 하위 클래스의 접근을 허용하는 동시에 외부 세계로부터 이 프로퍼티를 숨길 수 있다.

- 하위 클래스에서 정의하지 않은 상위 클래스의 함수를 호출하려면 `super`라는 키워드를 사용해야 한다.
  - `super`는 상위 클래스를 뜻하는 `superclass`에서 따온 키워드다.


#### 오버라이딩(overriding)
- 파생(하위) 클래스에서 기반(상위) 클래스와 **똑같은 시그니처를 갖는 함수**를 정의하면 기반 클래스에 정의됐던 함수가 수행하던 동작을 새로 정의한 함수의 동작으로 대체한다. 이를 **오버라이딩(overriding)**이라고 한다.
- 코틀린은 기반 클래스의 함수 시그니처와 똑같은 시그니처의 함수를 파생 클래스에서 발견하면 **우연히 오버라이드를 하는 실수를 저질렀다고 가정**한다.
  - 그래서 `override` 키워드가 필요하다는 오류 메세지를 표시한다.
- 코틀린은 우리가 `override` 키워드를 지정해서 "나는 오버라이드하고 있다"라는 의사를 표현하지 않으면 의도치 않게 똑같은 함수 이름과 파라미터 목록을 사용했다고 가정한다.
- `override`키워드를 쓰면 어떤 함수가 오버라이드한 함수인지 알아내기 위해 상위 클래스의 함수와 시그니처가 같은지 비교하지 않아도 되므로 코드를 읽을 때도 도움이 된다.
- 코틀린은 함수를 오버라이드할 때 또 다른 제약을 가한다.
  - 기반 클래스의 함수가 `open`으로 지정되어 있지 않으면 하위 클래스에서 이 함수를 오버라이드할 수 없다. 
- 코틀린에서는 **명확한 의도가 있지 않은 한 상속과 오버라이드가 불가능**하다.

## 함수

- 없음.

## 참고

이전까지 나왔던 내용 중 기반 클래스, 파생 클래스는 부모/자식, 혹은 상위/하위 클래스를 의미한다.