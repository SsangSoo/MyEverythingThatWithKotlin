# 아토믹 코틀린 At 32. 오버로딩

## 용어

#### overload
- '짐을 너무 많이 싣거나 무언가를 너무 많이 준다'는 뜻의 동사
- ~~(스타크래프트 오버로드 아님.ㅋㅋㅋㅋㅋ)~~

## 예약어 및 코틀린 개념

#### overload
- 함수의 이름을 대상으로 한다.
- **파라미터 목록이 여러 다른 함수에 같은 이름을 사용하는 것을 오버로딩**이라고 한다.

다음 예시 코드를 보자.

```kotlin
class Overloading {
    fun f() = 0
    fun f(n: Int) = n + 2
}

fun main() {
    val o = Overloading()
    o.f() eq 0
    o.f(11) eq 13
}
```

이름이 같은 두 가지 `f()`함수를 볼 수 있다.
**함수의 시그니처**는 함수 이름, 파라미터 목록, 반환 타입으로 이루어진다.
코틀린은 **시그니처를 비교해서 함수와 함수를 구분**한다.


- 함수를 오버로딩할 때는 함수 파라미터 리스트를 서로 다르게 만들어야 한다.(자바와 똑같다.)
- 함수의 반환 타입은 오버로딩의 대상이 아니다.(자바와 똑같다.)

**함수 시그니처**는 함수를 둘러싸고 있는 클래스(확장 함수의 경우 수신 객체 타입)도 포함한다.

어떤 클래스 안에 **확장 함수와 시그니처가 똑같은 멤버 함수가 들어있으면 코틀린은 멤버 함수를 우선시**한다.
하지만 확장 함수를 갖고 멤버 함수를 오버로딩할 수 있다.

```kotlin
class My {
    fun foo() = 0
}

fun My.foo() = 1            // 1. 멤버와 시그니처가 중복되는 확장 함수를 호출해도 의미가 없다. 이런 확장 함수는 결코 호출될 수 없다.

fun My.foo(i : Int) = i + 2 // 2. 다른 파라미터 목록을 제공함으로써 멤버 함수를 확장 함수로 오버로딩할 수 있다.

fun main() {
    My().foo() eq 0  // 0  
    My().foo(1) eq 3 // 3
}
```

함수 오버로딩과 디폴트 인자를 함꼐 사용하는 경우, 오버로딩한 함수를 호출하면 함수 시그니처와 함수 호출이 **가장 가깝게** 일치되는 함수를 호출한다.

**오버로딩이 왜 유용할까?**

- 오버로딩을 사용하면 '같은 주제를 다르게 변경한다.'는 개념을 (강제로 서로 다른 함수 이름을 써야 할 경우보다) 더 명확하게 표현할 수 있다.
- 일반적으로 프로그래머는 함수의 역할이나 함수가 대상을 처리하는 방법을 조합해서 유일한 이름을 만들어낸다. 이 때 오버로딩을 이용하면 훨씬 더 코드가 깔끔하다.


- 오버로딩이 있으면 가치가 있는 단순성을 얻을 수 있으므로 더 읽기 좋은 코드를 작성할 수 있게 된다.
= 오버로딩을 사용하면 함수 자체에 대해 설명하는 이름을 써서 추상화 수준을 높이고, 독자의 정신적인 부담을 줄일 수 있다.
- 또란 불필요한 중복을 줄여주기도 한다. 예를 들어 `addInt()`나 `addDouble()`이라는 이름은 근본적으로는 함수 파라미터에 있는 정보를 함수 이름에 반복하는 것일 뿐이다.


## 함수

- 없음.

## 참고

#### 디폴트 인자를 흉내 내기 위해 확장 함수를 사용하면 안 된다.
즉 다음과 같은 코드는 작성하지 말아야 한다.

```kotlin
fun f(n: Int) = n + 373
fun f() = f(0)

fun main() {
    f() eq 373
}
```

파라미터가 없는 함수는 첫 번째 함수만 호출할 뿐이다.
디폴트 인자를 사용해 이 두 함수를 한 함수로 바꿀 수 있다.

```kotlin
fun f(n: Int = 0) = n + 373

fun main() {
    f() eq 373
}
```

두 예제 모두 정숫값을 전달하지 않고 함수 `f()`를 호출할 수 있다.
하지만 아래의 코드쪽 방식을 권장한다.

